open Parser

let string_of_char = String.make 1

let string_of_token token = match token with
| EOF _ -> "EOF"
| IDENTIFIER ident -> "IDENTIFIER " ^ ident
| ABSTRACT _ -> "ABSTRACT"
| ASSERT _ -> "ASSERT"
| BOOLEAN _ -> "BOOLEAN"
| BREAK _ -> "BREAK"
| BYTE _ -> "BYTE"
| CASE _ -> "CASE"
| CATCH _ -> "CATCH"
| CHAR _ -> "CHAR" 
| CLASS _ -> "CLASS"
| CONST _ -> "CONST"
| CONTINUE _ -> "CONTINUE"
| DEFAULT _ -> "DEFAULT"
| DO _ -> "DO"
| DOUBLE _ -> "DOUBLE"
| ELSE _ -> "ELSE"
| ENUM _ -> "ENUM"
| EXTENDS _ -> "EXTENDS"
| FINAL _ -> "FINAL"
| FINALLY _ -> "FINALLY"
| FLOAT _ -> "FLOAT"
| FOR _ -> "FOR"
| GOTO _ -> "GOTO"
| IF _ -> "IF"
| IMPLEMENTS _ -> "IMPLEMENTS"
| IMPORT _ -> "IMPORT"
| INSTANCEOF _ -> "INSTANCEOF"
| INT _ -> "INT"
| INTERFACE _ -> "INTERFACE"
| LONG _ -> "LONG"
| NATIVE _ -> "NATIVE"
| NEW _ -> "NEW"
| PACKAGE _ -> "PACKAGE"
| PRIVATE _ -> "PRIVATE"
| PROTECTED _ -> "PROTECTED"
| PUBLIC _ -> "PUBLIC"
| RETURN _ -> "RETURN"
| SHORT _ -> "SHORT"
| STATIC _ -> "STATIC"
| STRICTFP _ -> "STRICTFP"
| SUPER _ -> "SUPER"
| SWITCH _ -> "SWITCH"
| SYNCHRONIZED _ -> "SYNCHRONIZED"
| THIS _ -> "THIS"
| THROW _ -> "THROW"
| THROWS _ -> "THROWS"
| TRANSIENT _ -> "TRANSIENT"
| TRY _ -> "TRY"
| VOID _ -> "VOID"
| VOLATILE _ -> "VOLATILE"
| WHILE _ -> "WHILE"
| INTEGER_LITERAL i -> "INTEGER_LITERAL " ^ i
| FLOAT_LITERAL f -> "FLOAT_LITERAL " ^ f
| BOOLEAN_LITERAL b -> "BOOLEAN_LITERAL " ^ b
| CHAR_LITERAL c -> "CHAR_LITERAL " ^ c
| STRING_LITERAL s -> "STRING_LITERAL " ^ s
| NULL_LITERAL _ -> "NULL_LITERAL"
| L_PAR _ -> "L_PAR"
| R_PAR _ -> "R_PAR"
| L_BRACE _ -> "L_BRACE"
| R_BRACE _ -> "R_BRACE"
| L_BRACKET _ -> "L_BRACKET"
| R_BRACKET _ -> "R_BRACKET"
| SEMICOLON _ -> "SEMICOLON"
| COMMA _ -> "COMMA"
| PERIOD _ -> "PERIOD"
| ASSIGN _ -> "ASSIGN"
| EQUAL _ -> "EQUAL"
| NOT_EQUAL _ -> "NOT_EQUAL"
| LOWER _ -> "LOWER"
| GREATER _ -> "GREATER"
| LOWER_OR_EQUAL _ -> "LOWER_OR_EQUAL"
| GREATER_OR_EQUAL _ -> "GREATER_OR_EQUAL"
| TERNARY_THEN _ -> "TERNARY_THEN"
| TERNARY_ELSE _ -> "TERNARY_ELSE"
| AND_LOGICAL _ -> "AND_LOGICAL"
| OR_LOGICAL _ -> "OR_LOGICAL"
| NOT_LOGICAL _ -> "NOT_LOGICAL"
| INCREMENT _ -> "INCREMENT "
| DECREMENT _ -> "DECREMENT "
| PLUS _ -> "PLUS"
| MINUS _ -> "MINUS"
| MULTIPLY _ -> "MULTIPLY"
| DIVIDE _ -> "DIVIDE"
| MODULO _ -> "MODULO"
| COMPLEMENT_BITWISE _ -> "COMPLEMENT_BITWISE"
| AND_BITWISE _ -> "AND_BITWISE"
| OR_BITWISE _ -> "OR_BITWISE"
| XOR_BITWISE _ -> "XOR_BITWISE"
| LEFT_SHIFT _ -> "LEFT_SHIFT"
| RIGHT_SHIFT _ -> "RIGHT_SHIFT"
| RIGHT_SHIFT_UNSIGNED _ -> "RIGHT_SHIFT_UNSIGNED"
| PLUS_ASSIGN _ -> "PLUS_ASSIGN"
| MINUS_ASSIGN _ -> "MINUS_ASSIGN"
| MULTIPLY_ASSIGN _ -> "MULTIPLY_ASSIGN"
| MINUS_ASSIGN _ -> "MINUS_ASSIGN"
| DIVIDE_ASSIGN _ -> "DIVIDE_ASSIGN"
| MODULUS_ASSIGN _ -> "MODULUS_ASSIGN"
| AND_BITWISE_ASSIGN _ -> "AND_BITWISE_ASSIGN"
| OR_BITWISE_ASSIGN _ -> "OR_BITWISE_ASSIGN"
| XOR_ASSIGN _ -> "XOR_ASSIGN"
| LEFT_SHIFT_ASSIGN _ -> "LEFT_SHIFT_ASSIGN"
| RIGHT_SHIFT_ASSIGN _ -> "RIGHT_SHIFT_ASSIGN"
| RIGHT_SHIFT_UNSIGNED_ASSIGN _ -> "RIGHT_SHIFT_UNSIGNED_ASSIGN"
| _ -> "UNKN"


let print_token token =
  print_endline (string_of_token token)

let rec print_lexbuf lexbuf =
  let token = Lexer.nexttoken lexbuf in
    match token with
      | EOF -> print_token token
      | _ -> print_token token; print_lexbuf lexbuf
